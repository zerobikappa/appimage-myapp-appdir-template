#!/bin/bash

# AppRun Script version
# date -u +%s
MYAPPRUN_VERSION=1645992904

#############################################
## prevent running by root/sudo for security concern
#zh# 出于安全考虑，阻止使用root/sudo权限运行
if [[ $(id -u) -eq 0 ]];
then
	echo "[AppRun]: prevent running by root/sudo"
	echo "[AppRun]: you should not using root/sudo to run this application"
	exit
fi
#############################################


#############################################
## env settings
#zh# 环境变量设置
SELF=$(readlink -f "$0")
# moved script from HERE(AppDir) to HERE/usr/bin, therefore use $APPDIR to replace $HERE
#zh# 把启动脚本的位置从原本的$APPDIR目录里移动到了APPDIR/usr/bin里了，所以去除$HERE并用$APPDIR代替
#HERE=${SELF%/*}
[[ -z $APPDIR ]] && APPDIR=${SELF%/usr/bin/*}
export PATH="${APPDIR}/usr/bin/:${APPDIR}/usr/sbin/:${APPDIR}/usr/games/:${APPDIR}/bin/:${APPDIR}/sbin/${PATH:+:$PATH}"
export LD_LIBRARY_PATH="${APPDIR}/usr/lib/:${APPDIR}/usr/lib/i386-linux-gnu/:${APPDIR}/usr/lib/x86_64-linux-gnu/:${APPDIR}/usr/lib32/:${APPDIR}/usr/lib64/:${APPDIR}/lib/:${APPDIR}/lib/i386-linux-gnu/:${APPDIR}/lib/x86_64-linux-gnu/:${APPDIR}/lib32/:${APPDIR}/lib64/${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
export PYTHONPATH="${APPDIR}/usr/share/pyshared/${PYTHONPATH:+:$PYTHONPATH}"
# if XDG_DATA_DIRS is empyt, after add ${APPDIR}/user/share/ into XDG_DATA_DIRS, also need to manual add default data path, otherwise local zenity could not load data files.
#zh# 把 ${APPDIR}/user/share 加入到 $XDG_DATA_DIRS 里，但如果 $XDG_DATA_DIRS 为空，还要把默认的 /usr/local/share/:/usr/share/ 也加进去，否则本地安装的图形界面zenity会无法找到文件。
#export XDG_DATA_DIRS="${APPDIR}/usr/share/${XDG_DATA_DIRS:+:$XDG_DATA_DIRS}"
export XDG_DATA_DIRS="${APPDIR}/usr/share/${XDG_DATA_DIRS:+:$XDG_DATA_DIRS}:/usr/local/share/:/usr/share/"
export PERLLIB="${APPDIR}/usr/share/perl5/:${APPDIR}/usr/lib/perl5/${PERLLIB:+:$PERLLIB}"
export GSETTINGS_SCHEMA_DIR="${APPDIR}/usr/share/glib-2.0/schemas/${GSETTINGS_SCHEMA_DIR:+:$GSETTINGS_SCHEMA_DIR}"
export QT_PLUGIN_PATH="${APPDIR}/usr/lib/qt4/plugins/:${APPDIR}/usr/lib/i386-linux-gnu/qt4/plugins/:${APPDIR}/usr/lib/x86_64-linux-gnu/qt4/plugins/:${APPDIR}/usr/lib32/qt4/plugins/:${APPDIR}/usr/lib64/qt4/plugins/:${APPDIR}/usr/lib/qt5/plugins/:${APPDIR}/usr/lib/i386-linux-gnu/qt5/plugins/:${APPDIR}/usr/lib/x86_64-linux-gnu/qt5/plugins/:${APPDIR}/usr/lib32/qt5/plugins/:${APPDIR}/usr/lib64/qt5/plugins/${QT_PLUGIN_PATH:+:$QT_PLUGIN_PATH}"
#EXEC=$(grep -e '^Exec=.*' "${APPDIR}"/*.desktop | head -n 1 | cut -d "=" -f 2 | cut -d " " -f 1)
#exec "${EXEC}" "$@"
#############################################


##############################################
## check *.cache directory
#zh# 检查 *.cache 目录

# if run directly from AppDir. 
#zh# 如果是直接从APPDIR里运行AppRun的情况
if [[ -z ${APPIMAGE} ]];
then
	export APPIMAGE="$APPDIR"
fi

#zh# 在这里我使用"appimage包的名字.cache"的目录，用作保存本地设置
#zh# 如果在APPIMAGE的同级目录里已经存在这个目录，那么就直接使用，电脑重启后不会消失
#zh# 如果这个目录不存在，那么就在/tmp/里建立这个目录，电脑重启后会消失
if [[ -d ${APPIMAGE}.cache ]];
then
	APPIMAGE_CACHE_DIR="${APPIMAGE}.cache"
else
	echo "directory  ${APPIMAGE}.cache/ not exist."
	echo "all data will be saved in /tmp/$(basename "$APPIMAGE").cache/ , which will be deleted after restart computer."
	echo "to keep your data, please run:"
	echo ""
	[[ -n $ARGV0 ]] && echo "  $ARGV0 --portable-cache" || echo "  ${APPIMAGE}/AppRun --portable-cache"
	echo ""
	echo "to create a cache directory."
	mkdir -p "/tmp/$(basename "$APPIMAGE").cache"
	APPIMAGE_CACHE_DIR="/tmp/$(basename "$APPIMAGE").cache"
fi
##############################################


##############################################
## setup unionfs temp directory for this app
#zh# 设定unionfs的挂载点和参数

#zh# 这个目录将用于存档win32和win64的$WINEPREFIX，如果你真的要把生成的 $WINEPREFIX 打包进appimage包里面的话
RO_ALLWINESTORGE="$APPDIR/usr/share/myapp" # Use the location where contain $WINEPREFIX, both win32 and win64 WINEPREFIX directory are here.

#zh# Use $APPDIR instead of $APPIMAGE, due to wine failed to handle too long file name with UNICODE characters.
#zh# wine 程序实际是从这个挂载点读写数据的，这里用了$APPDIR的名字，因为appimage文件的名字($APPIMAGE)如果太长而且包含unicode字符，会导致wine无法处理路径。appimage包释放时会自动生成一个不含unicode的短名字(也就是$APPDIR)，用这个作为挂载点的目录名。这个挂载点目录将会在游戏结束后被删除
MNT_ALLWINESTORGE="/tmp/$(basename "$APPDIR").unionfs/usr/share/myapp"

#zh# 对挂载点的写入更改会保存在 appimage包名字.cache 目录里，不会对本地目录造成任何更改
TMP_ALLWINESTORGE_OVERLAY="$APPIMAGE_CACHE_DIR/usr/share/myapp"


#zh# 读取数据从用户原本的家目录读取数据，这是有必要的。例如使用本地的图形界面kdialog时会需要从原本的$HOME目录里读取配置数据
#zh# 如果是用原本的经典配置(简单将 $XDG_CONFIG_HOME 变量重定向到 appimage包名字.config 目录)，会导致外部程序找不到配置文件
RO_HOMESTORGE="/home/$USER/"

#zh# Use $APPDIR instead of $APPIMAGE, due to wine failed to handle too long file name with UNICODE characters.
#zh# $HOME将会重定向到这个挂载点。这个挂载点目录将会在游戏结束后被删除
MNT_HOMESTORGE="/tmp/$(basename "$APPDIR").unionfs/home/public_user"

#zh# 对家目录$HOME的写入更改会保存在 appimage包名字.cache 目录里，不会对本地目录造成任何更改
TMP_HOMESTORGE_OVERLAY="$APPIMAGE_CACHE_DIR/home/public_user"
##############################################


##############################################
## setup standalone $HOME and $XDG_CONFIG_HOME directory
## not redirect $HOME and $XDG_CONFIG_HOME at this moment because exeinfo plugin need original $HOME and $XDG_CONFIG_HOME env.
#zh# 建立家目录与配置目录，这个时候不会立刻就将$HOME和$XDG_CONFIG_HOME重定向过去，因为之后的exeinfo-gen插件需要用到原本的环境变量

#zh# 为了让APPDIR与系统根目录保持相同结构，建立了public_user目录作为家目录，里面的.config目录作为配置目录
if [[ ! -d ${APPIMAGE_CACHE_DIR}/home/public_user/.config ]];
then
	mkdir -p "${APPIMAGE_CACHE_DIR}/home/public_user/.config"
fi

#zh# 如果用户自己使用了--appimage-portable-home(config) 选项建立了*.home和*.config的情况
if [[ -d ${APPIMAGE}.home ]];
then
	echo "${APPIMAGE}.home exists but is not necessary."
	echo "Because we default to use $APPIMAGE_CACHE_DIR/home/public_user/ to save related files."
fi

if [[ -d ${APPIMAGE}.config ]];
then
	echo "${APPIMAGE}.config exists but is not necessary."
	echo "Because we default to use $APPIMAGE_CACHE_DIR/home/public_user/.config to save related files."
fi

##############################################


##############################################
## setup WINE env
#zh# 配置wine环境变量

# default to run win64
#zh# 默认使用win64，但也保留可以在命令行里加 WINEARCH=win32 来运行appimage包
if [[ "$WINEARCH" == "win32" ]];
then
	export WINEARCH=win32
else
	export WINEARCH=win64
fi
export WINEPREFIX="$MNT_ALLWINESTORGE/myapp_prefix/wine.$WINEARCH/pfx"

# default to prevent wine showing "fixeme" message.
#zh# 默认不显示任何debug信息，对于普通用户来说这些信息太烦人了
if [[ -z $WINEDEBUG ]];
then
	export WINEDEBUG=-all
fi

# prevent wine setup application menu，no confirm if this setting was effected or not
#zh# 安装游戏时阻止在本地开始菜单建立项目，暂时不确定这项是不是真的生效了
export WINEDLLOVERRIDES=winemenubuilder.exe=d
##############################################


##############################################
## load exeinfo_profile, may depends on $WINEARCH, (if savedata in c drive,) should set the $WINEARCH first
#zh# exe程序的可执行文件名和路径、存档目录路径、游戏语言等信息保存在了一个叫 exeinfo_profile 的文件中。
#zh# 有些软件会在C盘保存存档，这时存档文件的路径将会包含$WINEARCH变量，
#zh# 所以把以下语句放在这里，确保已经设定好了$WINEARCH变量才执行以下语句
source "$APPDIR"/usr/bin/myapp-plugin-exeinfo-gen
exeinfo_load_file
##############################################


##############################################
## test runtime env
function debug_show(){
	cat << EOF
APPIMAGE=$APPIMAGE
APPDIR=$APPDIR
OWD=$OWD
ARGV0=$ARGV0
\$0=$0
EOF
}
[[ $MYAPPDEBUG -eq 1 ]] && debug_show
##############################################


##############################################
function print_help(){
	cat << EOF
run option:

  -s, --savedata
	load the full-completed savedata

  -w, --walkthrough
	open walkthrough with browser

  --browser=BROWSER_COMMAND
	only effect when -w is set.
	using another browser application to open
	walkthrough. for example, "--browser=firefox"
	means using firefox to open walkthrough.html

  -p, --portable-cache
	create \${APPIMAGE}.cache directory then exit.
	when running appimage, \$HOME and \$XDG_CONFIG_HOME
	will be redirect to this directory to prevent
	changing files in local \$HOME.

  -h, --help
	show this help then exit

  --version
	show application information and version


test option:

  -t, --test-winetricks
	open winetricks in temporary directory,
	use this option to test or install windows application.
	when this option set, -s and -w will be ignored.

  --exeinfo-gen [=gui|cli|zenity|kdialog]
		=gui :automatically find zenity or kdialog to run
		=cli :(only apply when launch from command line)
		=zenity :use zenity to run
		=kdialog :use kdialog to run
	after install windows application in AppDir,
	run "./AppRun --exeinfo-gen" to generate
	exeinfo_profile. default is "gui"


appimage option:

  --appimage-help
	show help about appimage function

  --appimage-extract [<pattern>]
	Extract content from embedded filesystem image
	If pattern is passed, only extract matching files

EOF
}

function print_version(){
	#zh# 这个函数用来打印appimage包里的游戏信息
	#zh# 就算你把appimage文件名改成乱七八糟
	#zh# 加上 --version 选项在命令行里运行就能在不启动游戏的同时查询里面的游戏信息
	if [[ -d $APPIMAGE ]];
	then
		#APPIMAGEKIT_VERSION="AppImageKit Version: (empty)(directly running from AppDir)"
		echo "***AppImageKit Version***"
		echo "(empty)(directly running from AppDir)"
	else
		#APPIMAGEKIT_VERSION="AppImageKit $($APPIMAGE --appimage-version)"	#NOTUSED: printed out wrong format
		echo "***AppImageKit Version***"
		$APPIMAGE --appimage-version
	fi
	if [[ -f "$APPDIR"/usr/share/myapp/myapp_exeinfo/exeinfo_profile ]];
	then
		source "$APPDIR"/usr/share/myapp/myapp_exeinfo/exeinfo_profile
	fi
	[[ -z $EXENAME ]] && EXENAME="(empty)(not set in AppDir)"
	APPLICATION_NAME=$(cat "$APPDIR"/*.desktop | grep -i "name=") && APPLICATION_NAME=${APPLICATION_NAME#*"="}
	APPLICATION_DESCRIPTION=$(cat "$APPDIR"/*.desktop | grep -i "comment=") && APPLICATION_DESCRIPTION=${APPLICATION_DESCRIPTION#*"="}
	cat << EOF

  ***Application Info***
  AppRun script version: $MYAPPRUN_VERSION
  .exe name: $EXENAME
  application name: $APPLICATION_NAME
  application description: $APPLICATION_DESCRIPTION

EOF
}
##############################################


##############################################
## option handling
#zh# 处理输入的选项
#zh# 我加了一层选项处理，定义了一些我自己的appimage包的专用选项，方便用户使用
#zh# 这些选项包括了例如：临时加载全通关的存档、打开打包在里面的攻略解说……等等的一些选项

#zh# NOTUSED: 我没有用getopt函数来处理选项，使用它无法处理未定义的选项，而有时我在调试时会希望能穿透我的选项层，把选项传递给下面的wine或winetricks
#parameters=$(getopt -o swth --long save-data,walkthrough,browser:,test-winetricks,help -n "$0" -- "$@")	# NOTUSED: because $(getopt) cannot ignore unknown options

parameters=$(echo "$@"|tr "=" " ")
eval set -- "$parameters"

function option_check(){
	if [[ ${1::2} == "--" ]];
	then
		echo "long"
	elif [[ ${1::1} == "-" ]];
	then
		echo "short"
	else
		echo "none"
	fi
}

while [[ -n "$1" ]] ; do
	case "$1" in
		-h| --help)
			print_help
			exit ;;
		--version)
			print_version
			exit ;;
		-s| --savedata)
			SAVEDATA_FLAG=1
			shift ;;
		-w| --walkthrough)
			WALKTHROUGH_FLAG=1
			shift ;;
		--browser)
			#i3-sensible-browser will choose $BROWSER to open walkthrough first
			[[ $(option_check "$2") != "none" ]] && echo "invalid option $1" >&2 && exit 1
			BROWSER="$2"
			shift 2;;
		-t| --test-winetricks)
			TEST_WINETRICKS_FLAG=1
			shift ;;
		--exeinfo-gen)
			EXEINFO_GEN_FLAG=1
			if [[ $2 == "zenity" ]];
			then
				EXEINFO_GEN_METHOD="zenity"
				shift 2
			elif [[ $2 == "kdialog" ]];
			then
				EXEINFO_GEN_METHOD="kdialog"
				shift 2
			elif [[ $2 == "gui" ]];
			then
				EXEINFO_GEN_METHOD="gui"
				shift 2
			elif [[ $2 == "cli" ]];
			then
				EXEINFO_GEN_METHOD="cli"
				shift 2
			else
				EXEINFO_GEN_METHOD="gui"
				shift
			fi
			;;
		-p| --portable-cache)
			mkdir -p "$APPIMAGE".cache/home/public_user/
			echo ""
			echo "created cache directory: $APPIMAGE.cache"
			exit ;;
		--)
			shift
			if [[ -z "$*" && -z "$next_parameters" ]];
			then
				break
			elif [[ ! $MYAPPDEBUG -eq 1 ]];
			then
				echo "[AppRun] error: not MYAPPDEBUG mode now. prevent to pass any unknown option." >&2
				echo "[AppRun] error: unknown options: $next_parameters $*" >&2
				exit
			else
				# then $next_parameters will be passed to wine
				next_parameters="$next_parameters $*"
				break
			fi
			;;
		*) 
			if [[ $MYAPPDEBUG -eq 1 ]];
			then
				next_parameters="$next_parameters $1"
				shift
			else
				echo "[AppRun] error: not MYAPPDEBUG mode now. prevent to pass any unknow option." >&2
				echo "[AppRun] error: unknown options: $1" >&2
				exit
			fi
			;;
	esac
done

# as the case<...>esac statement set above, if you want to debug your appimage and make some unknown option/argument passthrough to wine, you can follow:
# set the env: MYAPPDEBUG=1 (otherwise it will prevent unknown option/argument passthrough)
# then all unused option will be passed to wine.
# you can also place "--" before your option to avoid my script catching your option. for example:
# ./yourappimagename -s    the "-s" option will be catched by my script to run "load savedata"
# ./yourappimagename -- -s    the "-s" option will pass to wine
#zh# 就如上方的case语句那样，如果你在调试你的appimage包时，想穿透我的选项层传递一些未知参数给wine的话，那么你可以这样做：
#zh# 运行时设置环境变量： MYAPPDEBUG=1  (这是必须的，否则会默认阻止任何未知参数传入。普通方式打包出来的appimage包能允许你传入任何参数，这会有一定的安全隐患，所以我加了这一层限制。我的这个脚本主要用来打包wine游戏的，一般不需要什么额外的参数。)
#zh# 设置了这个环境变量后所有未定义的选项将会继续传到 wine 里。
#zh# 如果你要穿透的参数刚好是我的脚本里已定义的，那么你可以把它们放在 -- 后面，例如：
#zh# ./yourappimagename -s    这个-s选项会被我的脚本抓取，用来执行加载全通关存档的语句
#zh# ./yourappimagename -- -s    这个-s选项不会被我的脚本抓取，而是会继续传到下面的 wine 里。

# TODO: cannot handle grouped short option, such as "-sw" will be recognized as unknown option instead of "-s -w"
#zh# TODO: 无法处理连在一起的短选项，"-sw" 会被认为是未知选项，而不是"-s -w"两个短选项。
#zh# 初步思路是先过滤一遍长选项，把长选项执行了，然后把剩余选项开头是"-"的选项抽出来，交给getopt分割成一个个短选项，然后再进行二次过滤。

# the rest of option/argument will be passed to wine
#zh# 过滤后的剩余选项/参数会继续传递到下面的wine里
eval set -- "$next_parameters"

##############################################


##############################################
## extra filter for some option
#zh# 给一些参数的额外过滤

#zh# 另外编写了一些用于生成exe程序配置信息的脚本，太长了所以放在另一个脚本里，以插件的形式导入
source "$APPDIR"/usr/bin/myapp-plugin-exeinfo-gen

#zh# 如果用命令行模式运行exeinfo生成器，那么不需要挂载unionfs，直接在这里运行然后退出就可以了。
#zh# 如果用图形界面模式运行exeinfo生成器，那么zenity(gnome用户)或kdialog(kde用户)需要读取本地目录的一些配置文件，我没有把两者打包进appimage的打算，所以放在更下面的地方等挂载了unionfs再运行。
if [[ $EXEINFO_GEN_FLAG -eq 1 && $EXEINFO_GEN_METHOD == "cli" ]];
then
	exeinfo_main
	exit
fi

if [[ -z $EXENAME ]];
then
	[[ ! $TEST_WINETRICKS_FLAG -eq 1 ]] && echo "EXENAME not found in config file. auto set --test-winetricks , redirect to launch winetricks"
	TEST_WINETRICKS_FLAG=1
	EXENAME="$APPDIR/usr/bin/winetricks"
fi

# if --exeinfo-gen or --test-winetricks is set, then -s and -w will be ignored.
if [[ $TEST_WINETRICKS_FLAG -eq 1 || $EXEINFO_GEN_FLAG -eq 1 ]];
then
	[[ $SAVEDATA_FLAG -eq 1 ]] && SAVEDATA_FLAG=0 && echo "--savedata option ignored"
	[[ $WALKTHROUGH_FLAG -eq 1 ]] && WALKTHROUGH_FLAG=0 && echo "--walkthrough option ignored"
fi

# if --exeinfo-gen is set, then -t will be ignored.
if [[ $EXEINFO_GEN_FLAG -eq 1 ]];
then
	[[ $TEST_WINETRICKS_FLAG -eq 1 ]] && TEST_WINETRICKS_FLAG=0 && echo "--test-winetricks option ignored"
fi
##############################################


##############################################
## mount unionfs
#zh# 挂载unionfs

# before setup unionfs temp directory, check if exe is already running
#zh# 查看游戏是不是已经正在运行，这里我设置了禁止同一个游戏开启多个实例。玩单机游戏应该不需要多开吧。
if [[ -n "$EXENAME" && -n "$(pgrep -fi "$EXENAME")" ]];
then 
	echo "seems $EXENAME has been launched and is still running, plsease kill the process if the application encountered error" >&2
	exit 1
fi

#zh# 挂载不成功就退出，如果上一次不正常退出导致挂载点仍被占用就会出现这样的情况
#zh# 这里也隐含着如果同一个游戏已经开了一个实例，那么第二次打开会由于挂载点被占用而无法打开的情况
#zh# 加了上面的语句能让我分清楚错误退出的原因是哪一种情况
mkdir -p "$MNT_ALLWINESTORGE" "$TMP_ALLWINESTORGE_OVERLAY"
#$APPDIR/usr/bin/unionfs -o use_ino,nonempty,uid=$UID -ocow "$TMP_ALLWINESTORGE_OVERLAY"=RW:"$RO_ALLWINESTORGE"=RO "$MNT_ALLWINESTORGE" || exit 1
"$APPDIR"/usr/bin/unionfs -o use_ino,auto_unmount,nonempty,uid=$UID -ocow "$TMP_ALLWINESTORGE_OVERLAY"=RW:"$RO_ALLWINESTORGE"=RO "$MNT_ALLWINESTORGE" || exit 1

mkdir -p "$MNT_HOMESTORGE" "$TMP_HOMESTORGE_OVERLAY"
"$APPDIR"/usr/bin/unionfs -o use_ino,auto_unmount,nonempty,uid=$UID -ocow "$TMP_HOMESTORGE_OVERLAY"=RW:"$RO_HOMESTORGE"=RO "$MNT_HOMESTORGE" || exit 1
##############################################


##############################################
## restore wine prefix, should only run this function after unionfs is mounted, because $WINEPREFIX path include the unionfs drive
function wine_restore_prefix(){
	# "rm -rf" included, must check $WINEPREFIX first
	#zh# 有包含"rm -rf"语句，需要先检查好前面的$WINEPREFIX是否为空，避免删除了根目录的同名文件(如果恰好有的话)
	#zh# (同时也已经在脚本最开头设置了禁止root/sudo运行的设定)
	[[ -z "$WINEPREFIX" ]] && echo "[myapp:wine_restore_prefix] ERROR:\$WINEPREFIX not set, could not restore wine prefix." >&2 && return

	# only setup wineprefix and do nothing
	[[ ! -d $WINEPREFIX ]] && wine cmd /C exit

	echo "disable" > "$WINEPREFIX/.update-timestamp"

	#zh# 在这里我仅保留C盘和D盘，其它盘的软链接全删除了，避免wine透过Z盘(linux系统的根目录)对本地系统进行写入
	#zh# 是否真的有用还有待考察，就算删除了，只要在wine/winetricks里打开内置的文件管理窗，还是会重新生成，游戏结束后还要再删一次
	#zh# 不过删除多余盘符链接至少能避免打包一些不必要的东西进去appimage包里
	find "$WINEPREFIX/dosdevices" -mindepth 1 -maxdepth 1 ! -name "c:" ! -name "d:" -exec rm -rf "{}" \;
	[[ ! -L "$WINEPREFIX/dosdevices/c:" ]] && ln -sfnv ../drive_c "$WINEPREFIX/dosdevices/c:"
	#zh# 把D盘放在了WINEPREFIX的外面，只要游戏安装在D盘里，就算删除了WINEPREFIX也不需要重新安装游戏
	[[ ! -L "$WINEPREFIX/dosdevices/d:" ]] && ln -sfnv ../../../drive_d "$WINEPREFIX/dosdevices/d:"
	[[ ! -L "$MNT_ALLWINESTORGE/drive_d/myapp_patch_reg" ]] && ln -sfnv ../../../../myapp_patch_reg "$WINEPREFIX/drive_c/myapp_patch_reg"
	#zh# 把字体目录放在了WINEPREFIX的外面，如果有需要的话可以自己放一些必要的字体进去，不必担心WINEPREFIX被删除
	if [[ ! -L "$WINEPREFIX/drive_c/windows/Fonts" ]];
	then
		rm -rf "$WINEPREFIX/drive_c/windows/Fonts"
		#refer path: .../myapp/myapp_fonts
		#refer path: .../myapp/myapp_prefix/wine.wine64/pfx/drive_c/windows/Fonts
		ln -sfnv ../../../../../myapp_fonts "$WINEPREFIX/drive_c/windows/Fonts"
	fi
}

function wine_patch_reg(){
	# I tried to disable autostart winedbg via loading the .reg by regedit but failed. therefore I use winetricks to disable autostart debugger.
	#zh# 程序遇到崩溃时winedbg默认自动开启，但开启winedbg的时候大部分情况下它就一直挂在那里既无法打开winedbg也无法按ctrl+c退出进程
	#zh# 禁用自动开启后，程序崩溃时它会先弹窗问你要不要开启winedbg窗口，选择不开启的话它就会跳过然后正常结束进程
	#zh# 我仍保留着导入注册表来更改这个设定，但好像不太行，"Auto"一栏一直都是"1"(崩溃时自动开启调试)，原因不明
	#zh# 所以这里暂时也通过winetricks来关闭自动调试
	winetricks autostart_winedbg=disabled

	#zh# 有些安装版的游戏会写入信息在注册表里，如果删除了WINEPREFIX，就算游戏文件还在也无法运行游戏
	#zh# 那么可以导出相关的注册表保存在 myapp_patch_reg 目录里，每次开启游戏时自动导入，这样就无需将WINEPREFIX也打包进appimage包里
	#zh# 由于文件编码不同，如果是日文游戏的话必须在日文的环境变量下(LANG=ja_JP.UTF-8)开启winetricks导出注册表，否则导出的注册表将无法正常使用
	[[ -z "$(ls "$MNT_ALLWINESTORGE"/myapp_patch_reg/*.reg 2>/dev/null )" ]] && return
	for i in $(ls "$MNT_ALLWINESTORGE"/myapp_patch_reg/*.reg); do
		# ls /full/path/of/*.reg will output full path of file, need to use $(basename "$i") to get the file name.
		[[ -f $i ]] && i=$(basename "$i") || continue
		wine regedit "d:\\myapp_patch_reg\\$i"
	done

	#zh# 如果32位和64位的注册表不一样，那么可以分开存放在 myapp_patch_reg/win32/ 和 myapp_patch/win64/ 里面
	[[ -z "$(ls "$MNT_ALLWINESTORGE"/myapp_patch_reg/$WINEARCH/*.reg 2>/dev/null )" ]] && return
	for i in $(ls "$MNT_ALLWINESTORGE"/myapp_patch_reg/$WINEARCH/*.reg); do
		# ls /full/path/of/*.reg will output full path of file, need to use $(basename "$i") to get the file name.
		[[ -f $i ]] && i=$(basename "$i") || continue
		wine regedit "d:\\myapp_patch_reg\\$WINEARCH\\$i"
	done
}
##############################################


##############################################
## show the game walkthrough, you can see this info when using commandline to launch this app.
function walkthrough_browser(){
	#zh# 这个函数用来打开攻略网页
	#zh# 可以浏览攻略网站然后「将网页另存为」保存成一个.html文件，然后将.html文件放在 myapp_walkthrough 目录里，这样就可以一同打包到appimage包里
	#zh# 当然，出于安全考虑，建议将.html里的所有跳转链接删除
	#zh# 以 vim 为例，在命令模式下是:%s/href=".\{-}"//g
	cat << EOF
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@
  you can also click below html file to show game walkthrough:
@
EOF

	for i in $(ls "$MNT_ALLWINESTORGE/myapp_walkthrough"/*.html);
	do
		#echo "  file://$MNT_ALLWINESTORGE/drive_d/myapp_walkthrough/$i"
		# ls will output the full path if run -> ls /full/path/to/file/*.html
		echo "  file://$i"
	done

	cat << EOF
@
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

EOF
	#TODO: failed to using xdg-open to open html file.
	#zh#TODO: 改用了i3-sensible-browser脚本，因为使用xdg-open时系统不是用浏览器而是用文本编辑器打开.html文件
	#zh#TODO: 另外也考虑要不要为这个语句单独配一个选项，让它变为可选的，因为如果用户在 myapp_walkthrough 目录里放了很多.html的话，一旦使用-w(--walkthrough)选项要求打开攻略，那么这里会一次过打开所有html文件。
	i3-sensible-browser "$MNT_ALLWINESTORGE/myapp_walkthrough"/*.html
}

##############################################


##############################################
## game savedata
function savedata_replace(){
	#zh# 这个函数用来加载全通关存档，例如如果你打包的是爱情文字小说游戏，嗯，懂的都懂，那么你可以将全CG收集完成的存档放在 myapp_savedata 目录，当加了-s(--savedata)选项要求加载全通关存档时，会从这里提取存档覆盖当前存档。
	#zh# 原本的用户存档不会消失，而是加了后缀 .myapp.你的用户名.backup 在原目录里存放着，游戏结束后会还原回你的存档。
	#zh# 如果游戏不正常退出了，你也可以到游戏存档目录找到你的存档。
	if [[ $SAVEDATA_IN_HOME -eq 0 ]];
	then
		mkdir -p "$MNT_ALLWINESTORGE/$SAVEDATA_DIR"
		cp -r --suffix=.myapp."$USER".backup "$MNT_ALLWINESTORGE/myapp_savedata"/* "$MNT_ALLWINESTORGE/$SAVEDATA_DIR"
	elif [[ $SAVEDATA_IN_HOME -eq 1 ]];
	then
		mkdir -p "$MNT_HOMESTORGE/$SAVEDATA_DIR"
		cp -r --suffix=.myapp."$USER".backup "$MNT_ALLWINESTORGE/myapp_savedata"/* "$MNT_HOMESTORGE/$SAVEDATA_DIR"
	fi
}

function savedata_restore(){
	#zh# 这个函数用来还原用户存档。
	if [[ $SAVEDATA_IN_HOME -eq 0 ]];
	then
		FIND_DIR="$MNT_ALLWINESTORGE/$SAVEDATA_DIR"
	elif [[ $SAVEDATA_IN_HOME -eq 1 ]];
	then
		FIND_DIR="$MNT_HOMESTORGE/$SAVEDATA_DIR"
	else
		echo "[AppRun:savedata_restore] error: invalid FIND_DIR, cannot recover user savedata"
	fi

	echo "restore user savedata..."
	#SAVEDATA_RESTORE_LIST="$(find "$FIND_DIR" -type f -name "*.myapp.$USER.backup")"
	#for SAVEDATA_BACKUP in $SAVEDATA_RESTORE_LIST ; do	#NOT USED: could not handle filename with whitespace
	find "$FIND_DIR" -mindepth 1 -name "*.myapp.$USER.backup" -print0 | while read -d $'\0' SAVEDATA_BACKUP;
	do
		echo  "$SAVEDATA_BACKUP" ' >>to>> ' "${SAVEDATA_BACKUP%".myapp.$USER.backup"}"
		mv -f "$SAVEDATA_BACKUP" "${SAVEDATA_BACKUP%".myapp.$USER.backup"}"
	done
}

function savedata_show_location(){
cat << EOF
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@
@
  your savedata will be saved at file://$TMP_ALLWINESTORGE_OVERLAY/
@
@
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
EOF
}

##############################################



##############################################
## test runtime env
function debug_show(){
	cat << EOF
ready.

HOME=$HOME
XDG_CONFIG_HOME=$XDG_CONFIG_HOME
APPIMAGE=$APPIMAGE
APPDIR=$APPDIR
OWD=$OWD
ARGV0=$ARGV0
EOF
}
##############################################


##############################################
## launch app

#zh# 如果是使用图形界面模式运行exeinfo生成器，那么就是放在这里运行。因为此时unionfs已经加载了。
if [[ $EXEINFO_GEN_FLAG -eq 1 ]];
then
	[[ $EXEINFO_GEN_METHOD == "gui" || $EXEINFO_GEN_METHOD == "zenity" || $EXEINFO_GEN_METHOD == "kdialog" ]] && exeinfo_main
fi


if [[ ! $EXEINFO_GEN_FLAG -eq 1 ]];
then
	[[ -n $MYAPPLANG ]] && LANG=$MYAPPLANG || echo "MYAPPLANG not set, using current LANG:$LANG"
	# moved home and xdg_config_home env setting to here.
	# if change $HOME and $XDG_CONFIG_HOME too early, the exeinfo plugin may encounter some error related to file path.
	#zh# 在真正要启动wine之前才重定向 $HOME 和 $XDG_CONFIG_HOME 变量
	#zh# 如果太早重定向家目录和配置目录，上方的exeinfo生成器会有些小问题
	#zh# 具体来说就是zenity和kdialog的文件选择窗左边有些快捷入口，包含了HOME，如果按下得出的路径不是用户真正的家目录，而是重定向后的假HOME
	#zh# 并且这个路径无法被readlink还原回真正的路径
	export HOME=$MNT_HOMESTORGE
	echo \$HOME=$HOME
	export XDG_CONFIG_HOME="$MNT_HOMESTORGE/.config"
	echo \$XDG_CONFIG_HOME=$XDG_CONFIG_HOME
	echo "*****using $WINEARCH"
	if [[ $TEST_WINETRICKS_FLAG -eq 1 ]];
	then
		wine_restore_prefix
		#"$APPDIR"/usr/bin/winetricks sandbox	# this command run too slow
		wine_patch_reg
		#wineboot -es	# this command run too slow
		wineboot -s
		"$APPDIR"/usr/bin/winetricks "$@"
	else
		#zh# 除了因为有可能第一次运行游戏要生成WINEPREFIX之外，
		#zh# 还因为我重定向了D盘，所以无论如何都先重设一下WINEPREFIX，
		#zh# 确保一个正确的WINEPREFIX已经存在了
		wine_restore_prefix
		#"$APPDIR"/usr/bin/winetricks sandbox >/dev/null 2>&1	#NOTUSED: this command run too slow

		#zh# 如果指定了加载存档或显示攻略
		[[ $WALKTHROUGH_FLAG -eq 1 ]] && walkthrough_browser
		[[ $SAVEDATA_FLAG -eq 1 ]] && savedata_replace

		#zh# 启动游戏前先cd到可执行文件的所在目录，否则有些.exe文件无法正常运行
		cd "$MNT_ALLWINESTORGE/$EXE_LDIR" || exit 2 # Use the app installed location. Some .exe may not run if not cd into excute directory

		#zh# 如果有注册表补丁就导入
		wine_patch_reg

		#zh# 导入后进行一次wine关机的操作，这会等待上一步的注册表导入完成(效果有待考察)，
		#zh# 以防注册表还未写入就突然启动可执行文件，导致启动失败
		#wineboot -es	# this command run too slow
		wineboot -s

		#zh# 由于删除了C盘和D盘之外的所有链接，所以用DOS格式的路径传给wine
		#"$APPDIR"/usr/bin/winetricks sandbox >/dev/null 2>&1 && wine "${EXE_WROOT}:\\${EXE_WDIR}\\$EXENAME" "$@" 	# must use dos-style path instead of unix-style path if winetricks sandbox was set.
		wine "${EXE_WROOT}:\\${EXE_WDIR}\\$EXENAME" "$@"
	fi
fi


##############################################


##############################################
# monitor if the .exe is still running
# however, if the .exe file is only a launcher to launch other .exe files. pls change below code to monitor other the correct *.exe files.
function monitor_exe_running(){
	# if you find the $EXENAME is only a launcher to launch other *.exe,
	# you can uncomment below line to change the $EXENAME to another name.
	#zh# 这个函数用来持续监测游戏的可执行文件是不是还在运行，如果游戏退出了的话，这里就会结束循环，转去卸载unionfs的挂载点
	#zh# 经实测有部分游戏启动后会转到后台，不会占用bash的前台，导致bash继续执行下一步命令(卸载unionfs挂载点)
	#zh# 所以必须加上这个函数阻止bash在游戏未结束前就卸载挂载点
	#zh# 另外，有些可执行文件是作为启动器存在的，它会启动另一个真正的游戏可执行文件，然后它自己就会结束运行
	#zh# 如果是这种情况，你可以把下一行的注释去掉，手动将EXENAME重定向成另一个需要监测的可执行文件名字

	#EXENAME="another name"		# uncomment this line if you need to monitor *.exe with another name.
	[[ -z "$EXENAME" ]] && return

	if [[ -n "$(pgrep -fi "$EXENAME")" ]];
	then
		echo "$(pgrep -fai "$EXENAME")" '-------- running'
	fi

	while true
	do
		sleep 5
		if [[ -z "$(pgrep -fi "$EXENAME")" ]];
		then
			echo "$EXENAME was ended"
			break	# the $EXENAME exe is no longer running
		fi
	done
	# some application will change the reg in wine.
	# if return out of this function directly without waiting wine shutdown,
	# unionfs drive will be unmount immediately.
	# therefore we can add a "wineboot" command to wait for wine saving the registry.
	#zh# 有些游戏结束时会写入信息到注册表，在这里加入wine关机的语句，以防程序还没保存好资料就断开挂载点
	[[ ! $EXEINFO_GEN_FLAG -eq 1 ]] && wineboot -s
}
monitor_exe_running

##############################################


##############################################
## cleanup temp file

if [[ ! $EXEINFO_GEN_FLAG -eq 1 ]];
then
	#go back to $APPDIR, then remove temp file
	cd "$APPDIR" || exit 2

	echo "restore wine drive symlink entries..."
	wine_restore_prefix
	[[ $SAVEDATA_FLAG -eq 1 ]] && savedata_restore
fi

savedata_show_location


function atexit() {
	# "rm -rf" included, must check env first.
	#zh# 此处有包含"rm -rf"语句，需要先检查好前面的$APPDIR和$APPIMAGE_CACHE_DIR是否为空，避免删除了根目录的同名文件(如果恰好有的话)
	#zh# (同时也已经在脚本最开头设置了禁止root/sudo运行的设定)
	#zh# TODO: 考虑把 drive_d 目录从 usr/share/ 转移到 opt/ ，让不想用appimage包的用户可以直接将游戏安装在本地系统，安装后$APPDIR将变为空(因为APPDIR变成了根目录)，是否要兼容这种情况？
	[[ -z "$APPDIR" ]] && echo "[myapp:atexit] ERROR:\$APPDIR not set, could not clean temp files" >&2 && return
	[[ -z "$APPIMAGE_CACHE_DIR" ]] && echo "[myapp:atexit] ERROR:\$APPIMAGE_CACHE_DIR not set, could not clean temp files." >&2 && return

	echo "killing $APPDIR/usr/bin/unionfs"
	killall "$APPDIR/usr/bin/unionfs"
	sleep 1
	echo "Removing /tmp/$(basename "$APPDIR").unionfs"
	rm -rf "/tmp/$(basename "$APPDIR").unionfs"
	# if not clean up unionfs hide files, may encounter some read file error next time.
	#zh# 把残留的unionfs隐藏文件清理掉，否则下次启动游戏时可能会有读写错误导致无法进入游戏
	rm -rf "$APPIMAGE_CACHE_DIR/usr/share/myapp"/.unionfs* >/dev/null 2>&1
	rm -rf "$APPIMAGE_CACHE_DIR/home/public_user"/.unionfs* >/dev/null 2>&1
}
#set -e
#trap atexit EXIT	#NOT USED: due to some .exe(as game launcher) would pass EXIT signal after it completed to launch other .exe files. 
#zh# 这里没有用trap EXIT，有些启动器启动完游戏后就会立刻释放EXIT信号。
atexit


##############################################


